<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>はじめよう</title>

    <link rel="stylesheet" type="text/css" href="rustbook.css">

    
</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    
                <div id="nav">
                    <button id="toggle-nav">
                        <span class="sr-only">Toggle navigation</span>
                        <span class="bar"></span>
                        <span class="bar"></span>
                        <span class="bar"></span>
                    </button>
                </div>
<div id='toc' class='mobile-hidden'>
<ul class='chapter'>
<li><a  href='README.html'><b>1.</b> Introduction</a>
</li>
<li><a class='active' href='getting-started.html'><b>2.</b> はじめる</a>
</li>
<li><a  href='guessing-game.html'><b>3.</b> チュートリアル: 推測ゲーム</a>
</li>
<li><a  href='syntax-and-semantics.html'><b>4.</b> シンタックスとセマンティクス</a>
<ul class='section'>
<li><a  href='variable-bindings.html'><b>4.1.</b> 変数束縛</a>
</li>
<li><a  href='functions.html'><b>4.2.</b> 関数</a>
</li>
<li><a  href='primitive-types.html'><b>4.3.</b> プリミティブ型</a>
</li>
<li><a  href='comments.html'><b>4.4.</b> コメント</a>
</li>
<li><a  href='if.html'><b>4.5.</b> if</a>
</li>
<li><a  href='loops.html'><b>4.6.</b> ループ</a>
</li>
<li><a  href='ownership.html'><b>4.7.</b> 所有権</a>
</li>
<li><a  href='references-and-borrowing.html'><b>4.8.</b> 参照と借用</a>
</li>
<li><a  href='lifetimes.html'><b>4.9.</b> 生存期</a>
</li>
<li><a  href='mutability.html'><b>4.10.</b> 可変性</a>
</li>
<li><a  href='structs.html'><b>4.11.</b> 構造体</a>
</li>
<li><a  href='enums.html'><b>4.12.</b> 列挙型</a>
</li>
<li><a  href='match.html'><b>4.13.</b> マッチ</a>
</li>
<li><a  href='patterns.html'><b>4.14.</b> パターン</a>
</li>
<li><a  href='method-syntax.html'><b>4.15.</b> メソッド構文</a>
</li>
<li><a  href='vectors.html'><b>4.16.</b> ベクタ</a>
</li>
<li><a  href='strings.html'><b>4.17.</b> 文字列</a>
</li>
<li><a  href='generics.html'><b>4.18.</b> ジェネリクス</a>
</li>
<li><a  href='traits.html'><b>4.19.</b> トレイト</a>
</li>
<li><a  href='drop.html'><b>4.20.</b> Drop</a>
</li>
<li><a  href='if-let.html'><b>4.21.</b> if let</a>
</li>
<li><a  href='trait-objects.html'><b>4.22.</b> トレイトオブジェクト</a>
</li>
<li><a  href='closures.html'><b>4.23.</b> クロージャ</a>
</li>
<li><a  href='ufcs.html'><b>4.24.</b> 共通の関数呼出構文</a>
</li>
<li><a  href='crates-and-modules.html'><b>4.25.</b> クレイトとモジュール</a>
</li>
<li><a  href='const-and-static.html'><b>4.26.</b> `const`と`static`</a>
</li>
<li><a  href='attributes.html'><b>4.27.</b> アトリビュート</a>
</li>
<li><a  href='type-aliases.html'><b>4.28.</b> `type`エイリアス</a>
</li>
<li><a  href='casting-between-types.html'><b>4.29.</b> 型のキャスト</a>
</li>
<li><a  href='associated-types.html'><b>4.30.</b> 関連型</a>
</li>
<li><a  href='unsized-types.html'><b>4.31.</b> サイズ無し型</a>
</li>
<li><a  href='operators-and-overloading.html'><b>4.32.</b> 演算子とオーバーロード</a>
</li>
<li><a  href='deref-coercions.html'><b>4.33.</b> Derefによる型強制</a>
</li>
<li><a  href='macros.html'><b>4.34.</b> マクロ</a>
</li>
<li><a  href='raw-pointers.html'><b>4.35.</b> 生ポインタ</a>
</li>
<li><a  href='unsafe.html'><b>4.36.</b> `unsafe`</a>
</li>
</ul>
</li>
<li><a  href='effective-rust.html'><b>5.</b> Effective Rust</a>
<ul class='section'>
<li><a  href='the-stack-and-the-heap.html'><b>5.1.</b> スタックとヒープ</a>
</li>
<li><a  href='testing.html'><b>5.2.</b> テスト</a>
</li>
<li><a  href='conditional-compilation.html'><b>5.3.</b> 条件付きコンパイル</a>
</li>
<li><a  href='documentation.html'><b>5.4.</b> ドキュメント</a>
</li>
<li><a  href='iterators.html'><b>5.5.</b> イテレータ</a>
</li>
<li><a  href='concurrency.html'><b>5.6.</b> 並行</a>
</li>
<li><a  href='error-handling.html'><b>5.7.</b> エラーハンドリング</a>
</li>
<li><a  href='choosing-your-guarantees.html'><b>5.8.</b> 保証を選ぶ</a>
</li>
<li><a  href='ffi.html'><b>5.9.</b> FFI</a>
</li>
<li><a  href='borrow-and-asref.html'><b>5.10.</b> BorrowとAsRef</a>
</li>
<li><a  href='release-channels.html'><b>5.11.</b> リリースチャネル</a>
</li>
<li><a  href='using-rust-without-the-standard-library.html'><b>5.12.</b> 標準ライブラリ無しでRustを使う</a>
</li>
</ul>
</li>
<li><a  href='nightly-rust.html'><b>6.</b> Nightly Rust</a>
<ul class='section'>
<li><a  href='compiler-plugins.html'><b>6.1.</b> コンパイラプラグイン</a>
</li>
<li><a  href='inline-assembly.html'><b>6.2.</b> インラインアセンブリ</a>
</li>
<li><a  href='no-stdlib.html'><b>6.3.</b> No stdlib</a>
</li>
<li><a  href='intrinsics.html'><b>6.4.</b> イントリンシック</a>
</li>
<li><a  href='lang-items.html'><b>6.5.</b> 言語事項</a>
</li>
<li><a  href='advanced-linking.html'><b>6.6.</b> 高度なリンク</a>
</li>
<li><a  href='benchmark-tests.html'><b>6.7.</b> ベンチマークテスト</a>
</li>
<li><a  href='box-syntax-and-patterns.html'><b>6.8.</b> Box構文とパターン</a>
</li>
<li><a  href='slice-patterns.html'><b>6.9.</b> スライスパターン</a>
</li>
<li><a  href='associated-constants.html'><b>6.10.</b> 関連定数</a>
</li>
<li><a  href='custom-allocators.html'><b>6.11.</b> カスタムアロケータ</a>
</li>
</ul>
</li>
<li><a  href='glossary.html'><b>7.</b> 用語集</a>
</li>
<li><a  href='syntax-index.html'><b>8.</b> 構文の索引</a>
</li>
<li><a  href='bibliography.html'><b>9.</b> 関係書目</a>
</li>
</ul>
</div>
<div id='page-wrapper'>
<div id='page'>


    <h1 class="title">はじめよう</h1>
    <p>この一番最初の章でRustとツールの使い方をやっていきます。
最初にRustをインストールします。そしてお決まりの「Hello World」をやります。
最後にRustのビルドシステム兼パッケージマネージャのCargoについて話します。</p>

<h1 id='rustのインストール' class='section-header'><a href='#rustのインストール'>Rustのインストール</a></h1>
<p>Rustを使い始める最初のステップはインストールです。
このセクションのコマンドでインターネットからRustのダウンロードをするのでインターネットへの接続が必要でしょう。</p>

<p>コマンドを色々提示しますが、それらは全て<code>$</code>から始まります。<code>$</code>を入力する必要はありません。
<code>$</code>はただコマンドの先頭を示しているだけです。
これから、Web上でも「<code>$</code>で始まるものは一般ユーザで実行し<code>#</code>で始まるものは管理者権限で実行する」というルールに従ったチュートリアルや例をよく見ることになります。</p>

<h2 id='プラットフォームのサポート' class='section-header'><a href='#プラットフォームのサポート'>プラットフォームのサポート</a></h2>
<p>Rustのコンパイラは等しくサポートされている訳ではありませんが様々なプラットフォーム上で動き、様々なプラットフォームへとコンパイル出来ます。
Rustのサポートレベルは3階級に分かれていて、それぞれ違う保証をします。</p>

<p>プラットフォームはその「ターゲットトリプル」というどの種類のアウトプットを生成すべきかをコンパイラに伝える文字列で識別されます。
下記の表は対応するコンポーネントがそのプラットフォームで動作するかを示します。</p>

<h3 id='1級' class='section-header'><a href='#1級'>1級</a></h3>
<p>1級のプラットフォームは「ビルド出来かつ動くことを保証する」ものと思えます。
特に以下の要求それぞれを満たします。</p>

<ul>
<li>自動テストがそのプラットフォーム上で走るようセットアップされている</li>
<li><code>rust-lang/rust</code>レポジトリのmasterブランチへの変更はテストが通ってからされる</li>
<li>公式のリリースがそのプラットフォーム向けに提供される</li>
<li>使用方法及びビルド方法のドキュメントがある</li>
</ul>

<table>
<thead>
<tr>
<th>Target</th>
<th>std</th>
<th>rustc</th>
<th>cargo</th>
<th>notes</th>
</tr>
</thead>

<tbody>
<tr>
<td><code>x86_64-pc-windows-msvc</code></td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
<td>64-bit MSVC (Windows 7+)</td>
</tr>
<tr>
<td><code>i686-pc-windows-gnu</code></td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
<td>32-bit MinGW (Windows 7+)</td>
</tr>
<tr>
<td><code>x86_64-pc-windows-gnu</code></td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
<td>64-bit MinGW (Windows 7+)</td>
</tr>
<tr>
<td><code>i686-apple-darwin</code></td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
<td>32-bit OSX (10.7+, Lion+)</td>
</tr>
<tr>
<td><code>x86_64-apple-darwin</code></td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
<td>64-bit OSX (10.7+, Lion+)</td>
</tr>
<tr>
<td><code>i686-unknown-linux-gnu</code></td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
<td>32-bit Linux (2.6.18+)</td>
</tr>
<tr>
<td><code>x86_64-unknown-linux-gnu</code></td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
<td>64-bit Linux (2.6.18+)</td>
</tr>
</tbody>
</table>

<h3 id='2級' class='section-header'><a href='#2級'>2級</a></h3>
<p>段階2のプラットフォームは「ビルドを保証する」ものと思えます。
自動テストは走っておらず、ビルド出来たとしてもちゃんと動く保証はありませんが大抵ほぼ動きますしパッチはいつでも歓迎しています!
特に、以下が要請されています。</p>

<ul>
<li>自動ビルドはセットアップされているがテストは走っていないかもしれない</li>
<li><code>rust-lang/rust</code>レポジトリのmasterブランチへの変更は <strong>ビルドが</strong> 通ってからされる。
これは標準ライブラリしかコンパイル出来ないものもあれば完全なブートストラップまで出来るものもあることを意味するということに注意してください。</li>
<li>公式のリリースがそのプラットフォーム向けに提供される</li>
</ul>

<table>
<thead>
<tr>
<th>Target</th>
<th>std</th>
<th>rustc</th>
<th>cargo</th>
<th>notes</th>
</tr>
</thead>

<tbody>
<tr>
<td><code>i686-pc-windows-msvc</code></td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
<td>32-bit MSVC (Windows 7+)</td>
</tr>
<tr>
<td><code>x86_64-unknown-linux-musl</code></td>
<td>✓</td>
<td></td>
<td></td>
<td>64-bit Linux with MUSL</td>
</tr>
<tr>
<td><code>arm-linux-androideabi</code></td>
<td>✓</td>
<td></td>
<td></td>
<td>ARM Android</td>
</tr>
<tr>
<td><code>arm-unknown-linux-gnueabi</code></td>
<td>✓</td>
<td>✓</td>
<td></td>
<td>ARM Linux (2.6.18+)</td>
</tr>
<tr>
<td><code>arm-unknown-linux-gnueabihf</code></td>
<td>✓</td>
<td>✓</td>
<td></td>
<td>ARM Linux (2.6.18+)</td>
</tr>
<tr>
<td><code>aarch64-unknown-linux-gnu</code></td>
<td>✓</td>
<td></td>
<td></td>
<td>ARM64 Linux (2.6.18+)</td>
</tr>
<tr>
<td><code>mips-unknown-linux-gnu</code></td>
<td>✓</td>
<td></td>
<td></td>
<td>MIPS Linux (2.6.18+)</td>
</tr>
<tr>
<td><code>mipsel-unknown-linux-gnu</code></td>
<td>✓</td>
<td></td>
<td></td>
<td>MIPS (LE) Linux (2.6.18+)</td>
</tr>
</tbody>
</table>

<h3 id='3級' class='section-header'><a href='#3級'>3級</a></h3>
<p>3級のプラットフォームはサポートはされているものの、テストやビルドによる変更の管理は行なっていないものたちです。
コミュニティの貢献度で信頼性が定義されるのでビルドが通るかはまちまちです。
さらに、リリースやインストーラは提供されません。
しかしコミュニティが非公式な場所にリリースやインストーラを作れるインフラを持っているかもしれません。</p>

<table>
<thead>
<tr>
<th>Target</th>
<th>std</th>
<th>rustc</th>
<th>cargo</th>
<th>notes</th>
</tr>
</thead>

<tbody>
<tr>
<td><code>i686-linux-android</code></td>
<td>✓</td>
<td></td>
<td></td>
<td>32-bit x86 Android</td>
</tr>
<tr>
<td><code>aarch64-linux-android</code></td>
<td>✓</td>
<td></td>
<td></td>
<td>ARM64 Android</td>
</tr>
<tr>
<td><code>powerpc-unknown-linux-gnu</code></td>
<td>✓</td>
<td></td>
<td></td>
<td>PowerPC Linux (2.6.18+)</td>
</tr>
<tr>
<td><code>i386-apple-ios</code></td>
<td>✓</td>
<td></td>
<td></td>
<td>32-bit x86 iOS</td>
</tr>
<tr>
<td><code>x86_64-apple-ios</code></td>
<td>✓</td>
<td></td>
<td></td>
<td>64-bit x86 iOS</td>
</tr>
<tr>
<td><code>armv7-apple-ios</code></td>
<td>✓</td>
<td></td>
<td></td>
<td>ARM iOS</td>
</tr>
<tr>
<td><code>armv7s-apple-ios</code></td>
<td>✓</td>
<td></td>
<td></td>
<td>ARM iOS</td>
</tr>
<tr>
<td><code>aarch64-apple-ios</code></td>
<td>✓</td>
<td></td>
<td></td>
<td>ARM64 iOS</td>
</tr>
<tr>
<td><code>i686-unknown-freebsd</code></td>
<td>✓</td>
<td>✓</td>
<td></td>
<td>32-bit FreeBSD</td>
</tr>
<tr>
<td><code>x86_64-unknown-freebsd</code></td>
<td>✓</td>
<td>✓</td>
<td></td>
<td>64-bit FreeBSD</td>
</tr>
<tr>
<td><code>x86_64-unknown-openbsd</code></td>
<td>✓</td>
<td>✓</td>
<td></td>
<td>64-bit OpenBSD</td>
</tr>
<tr>
<td><code>x86_64-unknown-netbsd</code></td>
<td>✓</td>
<td>✓</td>
<td></td>
<td>64-bit NetBSD</td>
</tr>
<tr>
<td><code>x86_64-unknown-bitrig</code></td>
<td>✓</td>
<td>✓</td>
<td></td>
<td>64-bit Bitrig</td>
</tr>
<tr>
<td><code>x86_64-unknown-dragonfly</code></td>
<td>✓</td>
<td>✓</td>
<td></td>
<td>64-bit DragonFlyBSD</td>
</tr>
<tr>
<td><code>x86_64-rumprun-netbsd</code></td>
<td>✓</td>
<td></td>
<td></td>
<td>64-bit NetBSD Rump Kernel</td>
</tr>
<tr>
<td><code>i686-pc-windows-msvc</code> (XP)</td>
<td>✓</td>
<td></td>
<td></td>
<td>Windows XP support</td>
</tr>
<tr>
<td><code>x86_64-pc-windows-msvc</code> (XP)</td>
<td>✓</td>
<td></td>
<td></td>
<td>Windows XP support</td>
</tr>
</tbody>
</table>

<p>このテーブルは時間と共に拡張されるかもしれないことに注意して下さい。
これからの全ての3級のプラットフォームは網羅してないのです!</p>

<h2 id='linuxまたはmacにインストールする' class='section-header'><a href='#linuxまたはmacにインストールする'>LinuxまたはMacにインストールする</a></h2>
<p>LinuxかMacを使っているなら以下を入力するだけです</p>

<pre><code class="language-bash">$ curl -sSf https://static.rust-lang.org/rustup.sh | sh
</code></pre>

<p>このコマンドでスクリプトをダウンロードしインストールを始めます。
全て上手くいったら以下が表示される筈です。</p>

<pre><code class="language-text">Welcome to Rust.

This script will download the Rust compiler and its package manager, Cargo, and
install them to /usr/local. You may install elsewhere by running this script
with the --prefix=&lt;path&gt; option.

The installer will run under ‘sudo’ and may ask you for your password. If you do
not want the script to run ‘sudo’ then pass it the --disable-sudo flag.

You may uninstall later by running /usr/local/lib/rustlib/uninstall.sh,
or by running this script again with the --uninstall flag.

Continue? (y/N)
</code></pre>

<p>[訳注]:</p>

<pre><code class="language-text">Rustへようこそ。

このスクリプトはRustコンパイラとそのパッケジマネージャCargoをダウンロードし、/usr/local
へとインストールします。--prefix=&lt;path&gt; オプションを使うことで他の場所へインストール
出来ます。

インストーラは「sudo」下で走るのでパスワードを尋きます。もし&#39;sudo&#39;を使ってほしくないなら
--disable-sudo フラグを渡します。

You may uninstall later by running /usr/local/lib/rustlib/uninstall.sh,
or by running this script again with the --uninstall flag.

/usr/local/lib/rustlib/uninstall.shを実行するかこのスクリプトに--uninstallフラグを
付けて実行することで後程アインストール出来ます。

続けますか? (y/N)
</code></pre>

<p>ここで「はい」の意味で<code>y</code>を押しましょう。そして以後のプロンプトに従って下さい。</p>

<h2 id='windowsにインストール' class='section-header'><a href='#windowsにインストール'>Windowsにインストール</a></h2>
<p>Windowsを使っているなら適切な<a href="https://www.rust-lang.org/install.html">インストーラ</a>をダウンロードして下さい。</p>

<h2 id='アンインストール' class='section-header'><a href='#アンインストール'>アンインストール</a></h2>
<p>Rustのアンイストールはインストールと同じくらい簡単です。
LinuxかMacならアンインストールスクリプトを使って下さい。</p>

<pre><code class="language-bash">$ sudo /usr/local/lib/rustlib/uninstall.sh
</code></pre>

<p>Windowsのインストーラを使ったなら<code>.msi</code>をもう一度実行すればアンインストールのオプショが出てきます。</p>

<h2 id='トラブルシューティング' class='section-header'><a href='#トラブルシューティング'>トラブルシューティング</a></h2>
<p>既にRustをインストールしているならシェルを開いて以下を打ちましょう。</p>

<pre><code class="language-bash">$ rustc --version
</code></pre>

<p>バージョン番号、コミットハッシュ、そしてコミット日時が表示される筈です。</p>

<p>表示されたならRustはちゃんとインストールされています!おめでとう!</p>

<p>Windowsを使っていて、表示されないなら%PATHI%システム変数にRustが入っているか確認して下さい。
入っていなければもう一度インストーラを実行し、「Change,
repair, or remove installation」ページのの「Change」を選択し、「Add to PATH」がローカルのハードドライブにインストールされていることを確認して下さい。</p>

<p>もし上手くいかないなら様々な場所で助けを得られます。
最も簡単なのは<a href="http://chat.mibbit.com/?server=irc.mozilla.org&amp;channel=%23rust">Mibbit</a>からアクセス出来る<a href="irc://irc.mozilla.org/#rust">irc.mozilla.orgにある#rustチャネル</a>です。
リンクをクリックしたら他の助けを求めれるRustacean達(我々のことをふざけてこう呼ぶのです)とチャット出来ます。
他には<a href="https://users.rust-lang.org/">ユーザフォーラム</a>や<a href="http://stackoverflow.com/questions/tagged/rust">Stack Overflow</a>などがあります。</p>

<p>[訳注] TODO:日本語で会話出来るリソースを探す</p>

<p>インストーラはドキュメントのコピーもローカルにインストールしますので、オフラインで読めます。
UNIXシステムでは<code>/usr/local/share/doc/rust</code>にあります。
WindowsではRustをインストールした所の<code>share/doc</code>ディレクトリにあります。</p>

<h1 id='hello-world' class='section-header'><a href='#hello-world'>Hello, world!</a></h1>
<p>Rustをインストールしたので最初のRustのプログラムを書いていきましょう。
新しい言語を学ぶ時に「Hello, world!」とスクリーンに表示する小さなプログラムを書くのが伝統で、このセクションでもそれに従います。</p>

<p>このように小さなプログラムから始める利点はコンパイラがインストールされていて、正しく動くことを素早く確認出来ることです。
情報をスクリーンに表示することも非常によくやることなので早い内に練習しておくのが良いです。</p>

<blockquote>
<p>留意: 本書はコマンドラインをある程度使えることを仮定しています。Rust本体はコードの編集やツール群、
コードの置き場には特に要求を設けませんのでコマンドラインよりIDEを好むならそうしても構いません。
Rustを念頭に置いて作られたIDE、<a href="https://github.com/oakes/SolidOak">SolidOak</a>を試してみるといいかもしれません。
コミュニティにより多数の拡張が開発されていますし、Rustチームも<a href="https://github.com/rust-lang/rust/blob/master/src/etc/CONFIGS.md">様々なエディタ</a>向けにプラグインを用意しています。
このチュートリアルではエディタやIDEの設定は扱いませんのでそれぞれに合ったドキュメントを参照して下さい。</p>
</blockquote>

<h2 id='プロジェクトファイルを作る' class='section-header'><a href='#プロジェクトファイルを作る'>プロジェクトファイルを作る</a></h2>
<p>まず、Rustのコードを書くファイルを用意します。
Rustはコードがどこにあるかは気にしませんが本書を進めるにあたってホームディレクトリ下に
<em>projects</em> ディレクトリを作って全てのプロジェクトをそのディレクトリ下に入れることをお勧めます。
ターミナルを開いて以下のコマンドで今回のプロジェクトのディレクトリを作りましょう。</p>

<pre><code class="language-bash">$ mkdir ~/projects
$ cd ~/projects
$ mkdir hello_world
$ cd hello_world
</code></pre>

<blockquote>
<p>留意: WindowsでかつPowerShellを使っていないのなら <code>~</code>は上手く動かないかもしれません。
使っているシェルのドキュメントをあたってみて下さい。</p>
</blockquote>

<h2 id='rustのコードを書いて走らせる' class='section-header'><a href='#rustのコードを書いて走らせる'>Rustのコードを書いて走らせる</a></h2>
<p>次に、新しいソースファイルを作り、それを <em>main.rs</em> としましょう。
Rustのファイルは常に <em>.rs</em> 拡張子で終わります。ファイル名に1つ以上の単語を使うならアンダースコアで区切りましょう。
例えば、 <em>helloworld.rs</em> ではなく <em>hello_world.rs</em> を使うことになります。</p>

<p>それでは作った <em>main.rs</em> を開いて以下のコードを打ちましょう。</p>
<span class='rusttest'>fn main() {
    println!(&quot;Hello, world!&quot;);
}
</span><pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Hello, world!&quot;</span>);
}</pre>

<p>ファイルを保存して、ターミナルのウィンドウに戻ります。LinuxかOSXでは以下のコマンドを入力します。</p>

<pre><code class="language-bash">$ rustc main.rs
$ ./main
Hello, world!
</code></pre>

<p>Windowsでは<code>main</code>の代わりに<code>main.exe</code>を打ちます。使っているOSに関わらず、<code>Hello, world!</code>の文字列がターミナルに印字されるのを目にする筈です。
目にしたなら、おめでとうございます！あなたは正式にRustのプログラムを記述しました。これであなたもRustプログラマです！ようこそ。</p>

<h2 id='rustプログラムの解剖' class='section-header'><a href='#rustプログラムの解剖'>Rustプログラムの解剖</a></h2>
<p>さて、「Hello, world!」プログラムで何が起きていたのがつぶさに見ていきましょう。
パズルの最初のピースがこれです。</p>
<span class='rusttest'>fn main() {

}
</span><pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>main</span>() {

}</pre>

<p>これら行はRustの <em>関数</em> を定義します。<code>main</code>関数は特別です。全てのRustプログラムの開始点になります。
最初の行は「引数を取らず、返り値も返さない関数<code>main</code>を宣言します」といっています。
引数があれば、括弧(<code>(</code>と<code>)</code>)の中に入りますし、今回はこの関数から何も値を返さないので返り値の型を完全に省略出来ます。</p>

<p>さらに、関数の本体部がくるくる括弧(<code>{</code>と<code>}</code>)で括られていることに留意して下さい。
Rustは全ての関数の本体部にくるくる括弧を要請します。
関数宣言と同じ行に1スペース空けて開きくるくる括弧を置くのが良いスタイルとされます。</p>

<p><code>main()</code>関数の中では</p>
<span class='rusttest'>fn main() {
        println!(&quot;Hello, world!&quot;);
}</span><pre class='rust rust-example-rendered'>
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Hello, world!&quot;</span>);</pre>

<p>この行が今回の小さなプログラムの全てを担っています。これがテキストをスクリーンに印字するのです。
ここに重要な詳細がいくつもあります。1つ目はインデントが4スペースであり、タブでない点です。</p>

<p>2つ目の重要な部分は<code>println!()</code>の行です。これはRustのメタプログラミング機構、 <em><a href="macros.html">マクロ</a></em> の呼び出しです。
もし関数を呼び出しているのなら、<code>println()</code>のようになります(! がありません)。
Rustのマクロについては後程詳細に議論しますが、今のところ<code>!</code>を見たら普通の関数ではなくマクロを呼び出していることを意味するということだけ知っておいて下さい。</p>

<p>次は 文字列の<code>&quot;Hello, world&quot;</code>です。
システムプログラミング言語では文字列は驚くほど複雑なトピックで、これは <em><a href="the-stack-and-the-heap.html">静的に確保された</a></em> 文字列です。
文字列をスクリーンに印字してくれる<code>println!</code>にこれを引数として渡します。簡単ですね！</p>

<p>件の行はセミコロン(<code>;</code>)で終わります。Rustは <em><a href="glossary.html#%E5%BC%8F%E6%8C%87%E5%90%91%E8%A8%80%E8%AA%9E">式指向言語</a></em> で、ほとんどのものは文ではなく式になります。
<code>;</code>は式が終わり、次の式が始まることを示します。Rustのコードのほとんどの行は<code>;</code>で終わります。</p>

<h2 id='コンパイルと実行は別の手順' class='section-header'><a href='#コンパイルと実行は別の手順'>コンパイルと実行は別の手順</a></h2>
<p>「Rustのプログラムを書いて走らせる」で、新しく作ったプログラムをどうやって実行するか示しました。
それぞれを分解して手順毎に見ていきましょう。</p>

<p>Rustのプログラムを走らせる前に、コンパイルする必要があります。
Rustのコンパイラはこのように<code>rustc</code>と入力してソースファイルの名前を渡してあげることで使えます。</p>

<pre><code class="language-bash">$ rustc main.rs
</code></pre>

<p>CまたはC++のバックグラウンドを持つならこれが<code>gcc</code>や<code>clang</code>に似ていことに気付くでしょう。
コンパイルが成功したら、Rustは実行可能バイナリを吐いている筈です。
LinuxかOSXなら以下のように<code>ls</code>コマンドで確認出来ます。</p>

<pre><code class="language-bash">$ ls
main  main.rs
</code></pre>

<p>Windowsなら、こうなります。</p>

<pre><code class="language-bash">$ dir
main.exe  main.rs
</code></pre>

<p>2つのファイルがあるといっています。<code>.rs</code>拡張子を持ったソースコードと実行可能ファイル(Windowsでは<code>main.exe</code>、それ以外では<code>main</code>)。
ここからあとは<code>main</code>または<code>main.exe</code>のファイルをこのように実行するだけです。</p>

<pre><code class="language-bash">$ ./main  # あるいはWindowsならmain.exe
</code></pre>

<p>もし <em>main.rs</em> が「Hello, world!」プログラムなら、これで<code>Hello, world!</code>とターミナルに印字することでしょう。</p>

<p>もしRubyやPython、JavaScriptなどの動的な言語から来たのならコンパイルと実行が別の手順になっていることに馴れないでしょう。
Rustは、プログラムをコンパイルして、それを別の誰かに渡したら、Rustがなくても動く、 <em>事前コンパイル</em> 言語です。
他方別の誰かに<code>.rb</code>や<code>.py</code>、<code>.js</code>を渡したら(それぞれ)Ruby、PythonあるいはJavaScriptの実装が必要になりますが、コンパイルにも実行にも1つのコマンドで事足ります。
全ては言語設計上のトレードオフです。</p>

<p>単純なプログラムなら単に<code>rustc</code>でコンパイルすれば十分ですがプロジェクトが大きくなるにつれてプロジェクトの全てのオプションを管理したり他の人やプロジェクトと容易に共有出来るようにしたくなるでしょう。
次は現実世界のRustプログラムを書く手助けになるCargoというツールを紹介します。</p>

<h1 id='hello-cargo' class='section-header'><a href='#hello-cargo'>Hello, Cargo!</a></h1>
<p>CargoはRustのビルドシステムであり、パッケージマネージャでありRustaceanはCargoをRustプロジェクトの管理にも使います。
Cargoは3つのものを管理します、則ち、コードのビルド、コードが依存するライブラリのダウンロード、そしてそれらのライブラリのビルド。
それに依存するのでコードが必要とするライブラリを「依存」と呼びます。</p>

<p>最も簡単なRustのプログラムは依存を持たないのでここではCargoの1つめの機能だけを使います。
もっと複雑なRustのコードを書くにつれて、依存を追加したくなるでしょうが、Cargoを使えばそれがとても簡単に出来ます。</p>

<p>ほとんどもほとんどのRustのプロジェクトがCargoを使うのでこれ以後はCargoを使うものと仮定します。
公式のインストーラを使ったならCargoはRustに同梱されています。
他の手段でRustをインストールしたなら、以下のコマンドでCargoがインストールされているか確認出来ます。</p>

<pre><code class="language-bash">$ cargo --version
</code></pre>

<p>バージョン番号を確認出来たなら、良かった！「<code>コマンドが見つかりません</code>」などのエラーが出たなら
Rustをインストールしたシステムのドキュメントを見て、Cargoが別になっているか判断しましょう。</p>

<h2 id='corgoへ変換する' class='section-header'><a href='#corgoへ変換する'>Corgoへ変換する</a></h2>
<p>Hello WorldプログラムをCargoに変換しましょう。
プロジェクトをCargo化するには3つのことをする必要があります。</p>

<ol>
<li>ソースファイルを正しいディレクトリに置く</li>
<li>古い実行可能ファイル(Windowsなら<code>main.exe</code>、他では<code>main</code>)を消し、新しいものを作る</li>
<li>Cargoの設定ファイルを作る</li>
</ol>

<p>やっていきましょう!</p>

<h3 id='新しい実行可能ファイルとソースディレクトリを作る' class='section-header'><a href='#新しい実行可能ファイルとソースディレクトリを作る'>新しい実行可能ファイルとソースディレクトリを作る</a></h3>
<p>まず、ターミナルに戻って、 <em>hello_world</em> ディレクトリに行き、次のコマンドを打ちます。</p>

<pre><code class="language-bash">$ mkdir src
$ mv main.rs src/main.rs
$ rm main  # Windowsなら&#39;del main.exe&#39;になります
</code></pre>

<p>Cargoはソースファイルが <em>src</em> ディレクトリにあるものとして動くので、まずそうしましょう。
READMEやライセンス情報、他のコードに関係ないものはプロジェクト(このケースでは <em>hello_world</em>)直下に残したままになります。
こうすることでCargoを使えばプロジェクトを綺麗に整頓された状態を保てます。
すべてのものには場所があり、すべてが自身の場所に収まります。</p>

<p>では、 <em>main.rs</em> を <em>src</em> ディレクトリにコピーして、<code>rustc</code>でコンパイルして作ったファイルを削除します。
これまで通り、Windowsなら<code>main</code>を<code>main.exe</code>に読み替えて下さい。</p>

<p>今回の例では実行可能ファイルを作るので<code>main.rs</code>の名前を引き続き使います。
もしライブラリを作りたいなら<code>lib.rs</code>という名前にすることになります。
この規約はCargoでプロジェクトを正しくコンパイルするのに使われていますが、望むなら上書きすることも出来ます。</p>

<h3 id='設定ファイルを作る' class='section-header'><a href='#設定ファイルを作る'>設定ファイルを作る</a></h3>
<p>次に、 <em>hello_world</em> ディレクトリ下にファイルを作ります。それを<code>Cargo.toml</code>とします。</p>

<p>ちゃんと<code>Cargo.toml</code>の<code>C</code>が大文字になっていることを確認しましょう、そうしないとCargoが設定ファイルと認識出来なくなります。</p>

<p>このファイルは <em><a href="https://github.com/toml-lang/toml">TOML</a></em> (Tom&#39;s Obvious, Minimal Language ([訳注] Tomの理解しやすい、極小な言語) ) フォーマットで書かれます。
TOMLはINIに似ていますがいくつかの素晴しい機能が追加されていて、Cargoの設定フォーマットとして使わています。</p>

<p>ファイル内に以下の情報を打ち込みます。</p>

<pre><code class="language-toml">[package]

name = &quot;hello_world&quot;
version = &quot;0.0.1&quot;
authors = [ &quot;あなたの名前 &lt;you@example.com&gt;&quot; ]
</code></pre>

<p>最初の行、<code>[package]</code>は下に続く記述がパッケージの設定であることを示します。
さらなる情報をこのファイルに追加する時には他のセクションを追加することになりますが、今のところパッケージの設定しかしていません。</p>

<p>残りの3行はCargoがプログラムをコンパイルする時に必要な情報です。プログラムの名前、バージョン、そして著者です。</p>

<p>これらの情報を <em>Cargo.toml</em> ファイルに追加し終わったら、保存して設定ファイルの作成は終了です。</p>

<h2 id='cargoプロジェクトのビルドと実行' class='section-header'><a href='#cargoプロジェクトのビルドと実行'>Cargoプロジェクトのビルドと実行</a></h2>
<p><em>Cargo.toml</em> をプロジェクトのルートディレクトリに置いたら、Hello Worldプログラムのビルドと実行の準備が整っている筈です!
以下のコマンドを入力しましょう。</p>

<pre><code class="language-bash">$ cargo build
   Compiling hello_world v0.0.1 (file:///home/yourname/projects/hello_world)
$ ./target/debug/hello_world
Hello, world!
</code></pre>

<p>ババーン!全てが上手くいったら、もう一度<code>Hello, world!</code>がターミナルに印字される筈です。</p>

<p><code>cargo build</code>でプロジェクトをビルドして<code>./target/debug/hello_world</code>でそれを実行したのですが、実は次のように<code>cargo run</code>一発でそれらを実行出来ます。</p>

<pre><code class="language-bash">$ cargo run
     Running `target/debug/hello_world`
Hello, world!
</code></pre>

<p>この例でプロジェクトを再度ビルドしてないことに注意して下さい。
Cargoはファイルが変更されていないことが分かるのでバイナリの実行だけを行います。
ソースコードを修正していたら、Cargoは実行する前にプロジェクトを再度ビルドし、あなたはこのようなものを目にしたでしょう。</p>

<pre><code class="language-bash">$ cargo run
   Compiling hello_world v0.0.1 (file:///home/yourname/projects/hello_world)
     Running `target/debug/hello_world`
Hello, world!
</code></pre>

<p>Cargoはプロジェクトのファイルのどれかが変更されていないか確認し、最後にビルドしてから変更されたファイルがあるときにだけプロジェクトを再度ビルドします。</p>

<p>単純なプロジェクトではCargoを使っても単に<code>rustc</code>を使うのとさほど変わないでしょうが将来において役に立つでしょう。
特に、他の言語に於ける「library」や「package」にあたる、クレートを使い始めた時によく当て嵌ります。
複数のクレートで構成された複雑なプロジェクトではCargoにビルドを任せた方がとても簡単になります。
Cargoを使えば<code>cargo build</code>を実行するだけで正しく動いてくれます。</p>

<h2 id='リリースビルド' class='section-header'><a href='#リリースビルド'>リリースビルド</a></h2>
<p>最終的にプロジェクトのリリース準備が整ったら<code>cargo build --release</code>を使うことで最適化を掛けてプロジェクトをコンパイル出来ます。
最適化を掛けることでRustのコードは速くなりますが、コンパイル時間は長くなります。
こういう訳で、開発向けとユーザへ配布する最終版プログラムを作る時向けの2つの違うプロファイルが存在するのです。</p>

<p>このコマンドを走らせると <em>Cargo.lock</em> という新しいファイルも出来ます。
それの中身はこのようになっています。</p>

<pre><code class="language-toml">[root]
name = &quot;hello_world&quot;
version = &quot;0.0.1&quot;
</code></pre>

<p>Cargoは <em>Cargo.lock</em> でアプリケーションの依存を追跡します。
これはHello Worldプロジェクトの <em>Cargo.lock</em> ファイルです。
このプロジェクトは依存を持たないのでファイルの中身はほとんどありません。
実際には自身でこのファイルに触ることはありません。Cargoに任せてしまいます。</p>

<p>出来ました!ここまでついて来たならCargoで<code>hello_world</code>をビルドする所まで出来た筈です。</p>

<p>このプロジェクトはとてもシンプルですがこれからRustを使っていく上で実際に使うことになるツール類を色々使っています。
実際、事実上全てのRustプロジェクトで以下のコマンドの変形を使うことになります。</p>

<pre><code class="language-bash">$ git clone someurl.com/foo
$ cd foo
$ cargo build
</code></pre>

<h2 id='新たなcargoプロジェクを作る簡単な方法' class='section-header'><a href='#新たなcargoプロジェクを作る簡単な方法'>新たなCargoプロジェクを作る簡単な方法</a></h2>
<p>新たなプロジェクトを始めるのに先の手順を毎回踏む必要はありません!
Cargoで即座に開発を始められる骨組だけのプロジェクトを素早く作ることが出来ます。</p>

<p>Cargoで新たなプロジェクトを始めるには、<code>cargo new</code>をコマンドラインに入力します。</p>

<pre><code class="language-bash">$ cargo new hello_world --bin
</code></pre>

<p>ライブラリではなく実行可能アプリケーションを作りたいのでこのコマンドは<code>--bin</code>を渡しています。
実行可能ファイルはよく <em>バイナリ</em> と呼ばれます(なのでUnixシステムでは<code>/usr/bin/</code>に入っています)。</p>

<p>Cargoは2つのファイルと1つのディレクトリ、<code>Cargo.toml</code>と <em>main.rs</em> の入った <em>src</em> ディレクトリを生成します。
上で作ったのと全く同じ、見たことのある構成ですね。</p>

<p>これさえあれば始められます。まず、<code>Cargo.toml</code>を開きます。このようになっている筈です。</p>

<pre><code class="language-toml">[package]

name = &quot;hello_world&quot;
version = &quot;0.1.0&quot;
authors = [&quot;あなたの名前 &lt;you@example.com&gt;&quot;]
</code></pre>

<p>Cargoは引数と<code>git</code>の設定を基に <em>Cargo.toml</em> に適当な値を埋めます。
Cargoが<code>hello_world</code>ディレクトリを<code>git</code>レポジトリとして初期化していることにも気付くでしょう。</p>

<p>Here’s what should be in <code>src/main.rs</code>:</p>

<p><code>src/main.rs</code>の中身はこのようになっている筈です。</p>
<span class='rusttest'>fn main() {
    println!(&quot;Hello, world!&quot;);
}
</span><pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Hello, world!&quot;</span>);
}</pre>

<p>Cargoが「Hello World!」を生成したのでコードを書き始められます!</p>

<blockquote>
<p>留意: Cargoについて詳しく見たいなら、公式の<a href="http://doc.crates.io/guide.html">Cargoガイド</a>を見ましょう。全ての機能が網羅してあります。</p>
</blockquote>

<h1 id='終わりに' class='section-header'><a href='#終わりに'>終わりに</a></h1>
<p>この章はこれ以後の本書、そしてあなたがRustを書いていく上で役に立つ基本を扱いました。
ツールについては一歩踏み出したのでRust言語自体を扱っていきます。</p>

<p>2つの選択肢があります。
<a href="learn-rust.html">Rustを学ぶ</a>でプロジェクトをやるか、<a href="syntax-and-semantics.html">シンタックスとセマンティクス</a>で下から進んでいくかです。
経験豊富なシステムプログラマなら「Rustを学ぶ」が好みでしょうが、動的なバックグラウンドを持つ人なら他方が馴染むでしょう。
違う人同士違う学び方をするのです!自分に合ったものを選びましょう。</p>

    <script type="text/javascript">
        window.playgroundUrl = "https://play.rust-lang.org";
    </script>
    <script src='rustbook.js'></script>
<script src='playpen.js'></script>
</div></div>


</body>
</html>
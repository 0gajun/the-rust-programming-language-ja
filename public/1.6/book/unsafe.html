<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>Unsafe</title>

    <link rel="stylesheet" type="text/css" href="rustbook.css">

    
</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    
                <div id="nav">
                    <button id="toggle-nav">
                        <span class="sr-only">Toggle navigation</span>
                        <span class="bar"></span>
                        <span class="bar"></span>
                        <span class="bar"></span>
                    </button>
                </div>
<div id='toc' class='mobile-hidden'>
<ul class='chapter'>
<li><a  href='README.html'><b>1.</b> Introduction</a>
</li>
<li><a  href='getting-started.html'><b>2.</b> はじめる</a>
</li>
<li><a  href='learn-rust.html'><b>3.</b> Rustを学ぶ</a>
<ul class='section'>
<li><a  href='guessing-game.html'><b>3.1.</b> 数当てゲーム</a>
</li>
<li><a  href='dining-philosophers.html'><b>3.2.</b> 哲学者の晩餐</a>
</li>
<li><a  href='rust-inside-other-languages.html'><b>3.3.</b> 他言語と共存する</a>
</li>
</ul>
</li>
<li><a  href='syntax-and-semantics.html'><b>4.</b> シンタックスとセマンティクス</a>
<ul class='section'>
<li><a  href='variable-bindings.html'><b>4.1.</b> 変数束縛</a>
</li>
<li><a  href='functions.html'><b>4.2.</b> 関数</a>
</li>
<li><a  href='primitive-types.html'><b>4.3.</b> プリミティブ型</a>
</li>
<li><a  href='comments.html'><b>4.4.</b> コメント</a>
</li>
<li><a  href='if.html'><b>4.5.</b> if</a>
</li>
<li><a  href='loops.html'><b>4.6.</b> ループ</a>
</li>
<li><a  href='ownership.html'><b>4.7.</b> 所有権</a>
</li>
<li><a  href='references-and-borrowing.html'><b>4.8.</b> 参照と借用</a>
</li>
<li><a  href='lifetimes.html'><b>4.9.</b> 生存期</a>
</li>
<li><a  href='mutability.html'><b>4.10.</b> 可変性</a>
</li>
<li><a  href='structs.html'><b>4.11.</b> 構造体</a>
</li>
<li><a  href='enums.html'><b>4.12.</b> 列挙型</a>
</li>
<li><a  href='match.html'><b>4.13.</b> マッチ</a>
</li>
<li><a  href='patterns.html'><b>4.14.</b> パターン</a>
</li>
<li><a  href='method-syntax.html'><b>4.15.</b> メソッド構文</a>
</li>
<li><a  href='vectors.html'><b>4.16.</b> ベクタ</a>
</li>
<li><a  href='strings.html'><b>4.17.</b> 文字列</a>
</li>
<li><a  href='generics.html'><b>4.18.</b> ジェネリクス</a>
</li>
<li><a  href='traits.html'><b>4.19.</b> トレイト</a>
</li>
<li><a  href='drop.html'><b>4.20.</b> Drop</a>
</li>
<li><a  href='if-let.html'><b>4.21.</b> if let</a>
</li>
<li><a  href='trait-objects.html'><b>4.22.</b> トレイトオブジェクト</a>
</li>
<li><a  href='closures.html'><b>4.23.</b> クロージャ</a>
</li>
<li><a  href='ufcs.html'><b>4.24.</b> 共通の関数呼出構文</a>
</li>
<li><a  href='crates-and-modules.html'><b>4.25.</b> クレイトとモジュール</a>
</li>
<li><a  href='const-and-static.html'><b>4.26.</b> `const`と`static`</a>
</li>
<li><a  href='attributes.html'><b>4.27.</b> アトリビュート</a>
</li>
<li><a  href='type-aliases.html'><b>4.28.</b> `type`エイリアス</a>
</li>
<li><a  href='casting-between-types.html'><b>4.29.</b> 型のキャスト</a>
</li>
<li><a  href='associated-types.html'><b>4.30.</b> 関連型</a>
</li>
<li><a  href='unsized-types.html'><b>4.31.</b> サイズ無し型</a>
</li>
<li><a  href='operators-and-overloading.html'><b>4.32.</b> 演算子とオーバーロード</a>
</li>
<li><a  href='deref-coercions.html'><b>4.33.</b> Derefによる型強制</a>
</li>
<li><a  href='macros.html'><b>4.34.</b> マクロ</a>
</li>
<li><a  href='raw-pointers.html'><b>4.35.</b> 生ポインタ</a>
</li>
<li><a class='active' href='unsafe.html'><b>4.36.</b> `unsafe`</a>
</li>
</ul>
</li>
<li><a  href='effective-rust.html'><b>5.</b> Effective Rust</a>
<ul class='section'>
<li><a  href='the-stack-and-the-heap.html'><b>5.1.</b> スタックとヒープ</a>
</li>
<li><a  href='testing.html'><b>5.2.</b> テスト</a>
</li>
<li><a  href='conditional-compilation.html'><b>5.3.</b> 条件付きコンパイル</a>
</li>
<li><a  href='documentation.html'><b>5.4.</b> ドキュメント</a>
</li>
<li><a  href='iterators.html'><b>5.5.</b> イテレータ</a>
</li>
<li><a  href='concurrency.html'><b>5.6.</b> 並行</a>
</li>
<li><a  href='error-handling.html'><b>5.7.</b> エラーハンドリング</a>
</li>
<li><a  href='choosing-your-guarantees.html'><b>5.8.</b> 保証を選ぶ</a>
</li>
<li><a  href='ffi.html'><b>5.9.</b> FFI</a>
</li>
<li><a  href='borrow-and-asref.html'><b>5.10.</b> BorrowとAsRef</a>
</li>
<li><a  href='release-channels.html'><b>5.11.</b> リリースチャネル</a>
</li>
<li><a  href='using-rust-without-the-standard-library.html'><b>5.12.</b> 標準ライブラリ無しでRustを使う</a>
</li>
</ul>
</li>
<li><a  href='nightly-rust.html'><b>6.</b> Nightly Rust</a>
<ul class='section'>
<li><a  href='compiler-plugins.html'><b>6.1.</b> コンパイラプラグイン</a>
</li>
<li><a  href='inline-assembly.html'><b>6.2.</b> インラインアセンブリ</a>
</li>
<li><a  href='no-stdlib.html'><b>6.3.</b> No stdlib</a>
</li>
<li><a  href='intrinsics.html'><b>6.4.</b> イントリンシック</a>
</li>
<li><a  href='lang-items.html'><b>6.5.</b> 言語事項</a>
</li>
<li><a  href='advanced-linking.html'><b>6.6.</b> 高度なリンク</a>
</li>
<li><a  href='benchmark-tests.html'><b>6.7.</b> ベンチマークテスト</a>
</li>
<li><a  href='box-syntax-and-patterns.html'><b>6.8.</b> Box構文とパターン</a>
</li>
<li><a  href='slice-patterns.html'><b>6.9.</b> スライスパターン</a>
</li>
<li><a  href='associated-constants.html'><b>6.10.</b> 関連定数</a>
</li>
<li><a  href='custom-allocators.html'><b>6.11.</b> カスタムアロケータ</a>
</li>
</ul>
</li>
<li><a  href='glossary.html'><b>7.</b> 用語集</a>
</li>
<li><a  href='syntax-index.html'><b>8.</b> 構文の索引</a>
</li>
<li><a  href='bibliography.html'><b>9.</b> 関係書目</a>
</li>
</ul>
</div>
<div id='page-wrapper'>
<div id='page'>


    <h1 class="title">Unsafe</h1>
    <p>Rust’s main draw is its powerful static guarantees about behavior. But safety
checks are conservative by nature: there are some programs that are actually
safe, but the compiler is not able to verify this is true. To write these kinds
of programs, we need to tell the compiler to relax its restrictions a bit. For
this, Rust has a keyword, <code>unsafe</code>. Code using <code>unsafe</code> has less restrictions
than normal code does.</p>

<p>Let’s go over the syntax, and then we’ll talk semantics. <code>unsafe</code> is used in
four contexts. The first one is to mark a function as unsafe:</p>
<span class='rusttest'>fn main() {
    unsafe fn danger_will_robinson() {
        // scary stuff
    }
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>unsafe</span> <span class='kw'>fn</span> <span class='ident'>danger_will_robinson</span>() {
    <span class='comment'>// scary stuff</span>
}</pre>

<p>All functions called from <a href="ffi.html">FFI</a> must be marked as <code>unsafe</code>, for example.
The second use of <code>unsafe</code> is an unsafe block:</p>
<span class='rusttest'>fn main() {
    unsafe {
        // scary stuff
    }
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>unsafe</span> {
    <span class='comment'>// scary stuff</span>
}</pre>

<p>The third is for unsafe traits:</p>
<span class='rusttest'>fn main() {
    unsafe trait Scary { }
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>unsafe</span> <span class='kw'>trait</span> <span class='ident'>Scary</span> { }</pre>

<p>And the fourth is for <code>impl</code>ementing one of those traits:</p>
<span class='rusttest'>fn main() {
    unsafe trait Scary { }
    unsafe impl Scary for i32 {}
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>unsafe</span> <span class='kw'>impl</span> <span class='ident'>Scary</span> <span class='kw'>for</span> <span class='ident'>i32</span> {}</pre>

<p>It’s important to be able to explicitly delineate code that may have bugs that
cause big problems. If a Rust program segfaults, you can be sure it’s somewhere
in the sections marked <code>unsafe</code>.</p>

<h1 id='what-does-safe-mean' class='section-header'><a href='#what-does-safe-mean'>What does ‘safe’ mean?</a></h1>
<p>Safe, in the context of Rust, means ‘doesn’t do anything unsafe’. It’s also
important to know that there are certain behaviors that are probably not
desirable in your code, but are expressly <em>not</em> unsafe:</p>

<ul>
<li>Deadlocks</li>
<li>Leaks of memory or other resources</li>
<li>Exiting without calling destructors</li>
<li>Integer overflow</li>
</ul>

<p>Rust cannot prevent all kinds of software problems. Buggy code can and will be
written in Rust. These things aren’t great, but they don’t qualify as <code>unsafe</code>
specifically.</p>

<p>In addition, the following are all undefined behaviors in Rust, and must be
avoided, even when writing <code>unsafe</code> code:</p>

<ul>
<li>Data races</li>
<li>Dereferencing a null/dangling raw pointer</li>
<li>Reads of <a href="http://llvm.org/docs/LangRef.html#undefined-values">undef</a> (uninitialized) memory</li>
<li>Breaking the <a href="http://llvm.org/docs/LangRef.html#pointer-aliasing-rules">pointer aliasing rules</a> with raw pointers.</li>
<li><code>&amp;mut T</code> and <code>&amp;T</code> follow LLVM’s scoped <a href="http://llvm.org/docs/LangRef.html#noalias">noalias</a> model, except if
the <code>&amp;T</code> contains an <code>UnsafeCell&lt;U&gt;</code>. Unsafe code must not violate these
aliasing guarantees.</li>
<li>Mutating an immutable value/reference without <code>UnsafeCell&lt;U&gt;</code></li>
<li>Invoking undefined behavior via compiler intrinsics:

<ul>
<li>Indexing outside of the bounds of an object with <code>std::ptr::offset</code>
(<code>offset</code> intrinsic), with
the exception of one byte past the end which is permitted.</li>
<li>Using <code>std::ptr::copy_nonoverlapping_memory</code> (<code>memcpy32</code>/<code>memcpy64</code>
intrinsics) on overlapping buffers</li>
</ul></li>
<li>Invalid values in primitive types, even in private fields/locals:

<ul>
<li>Null/dangling references or boxes</li>
<li>A value other than <code>false</code> (0) or <code>true</code> (1) in a <code>bool</code></li>
<li>A discriminant in an <code>enum</code> not included in its type definition</li>
<li>A value in a <code>char</code> which is a surrogate or above <code>char::MAX</code></li>
<li>Non-UTF-8 byte sequences in a <code>str</code></li>
</ul></li>
<li>Unwinding into Rust from foreign code or unwinding from Rust into foreign
code.</li>
</ul>

<h1 id='unsafe-superpowers' class='section-header'><a href='#unsafe-superpowers'>Unsafe Superpowers</a></h1>
<p>In both unsafe functions and unsafe blocks, Rust will let you do three things
that you normally can not do. Just three. Here they are:</p>

<ol>
<li>Access or update a <a href="const-and-static.html#static">static mutable variable</a>.</li>
<li>Dereference a raw pointer.</li>
<li>Call unsafe functions. This is the most powerful ability.</li>
</ol>

<p>That’s it. It’s important that <code>unsafe</code> does not, for example, ‘turn off the
borrow checker’. Adding <code>unsafe</code> to some random Rust code doesn’t change its
semantics, it won’t just start accepting anything. But it will let you write
things that <em>do</em> break some of the rules.</p>

<p>You will also encounter the <code>unsafe</code> keyword when writing bindings to foreign
(non-Rust) interfaces. You&#39;re encouraged to write a safe, native Rust interface
around the methods provided by the library.</p>

<p>Let’s go over the basic three abilities listed, in order.</p>

<h2 id='access-or-update-a-static-mut' class='section-header'><a href='#access-or-update-a-static-mut'>Access or update a <code>static mut</code></a></h2>
<p>Rust has a feature called ‘<code>static mut</code>’ which allows for mutable global state.
Doing so can cause a data race, and as such is inherently not safe. For more
details, see the <a href="const-and-static.html#static">static</a> section of the book.</p>

<h2 id='dereference-a-raw-pointer' class='section-header'><a href='#dereference-a-raw-pointer'>Dereference a raw pointer</a></h2>
<p>Raw pointers let you do arbitrary pointer arithmetic, and can cause a number of
different memory safety and security issues. In some senses, the ability to
dereference an arbitrary pointer is one of the most dangerous things you can
do. For more on raw pointers, see <a href="raw-pointers.html">their section of the book</a>.</p>

<h2 id='call-unsafe-functions' class='section-header'><a href='#call-unsafe-functions'>Call unsafe functions</a></h2>
<p>This last ability works with both aspects of <code>unsafe</code>: you can only call
functions marked <code>unsafe</code> from inside an unsafe block.</p>

<p>This ability is powerful and varied. Rust exposes some <a href="intrinsics.html">compiler
intrinsics</a> as unsafe functions, and some unsafe functions bypass
safety checks, trading safety for speed.</p>

<p>I’ll repeat again: even though you <em>can</em> do arbitrary things in unsafe blocks
and functions doesn’t mean you should. The compiler will act as though you’re
upholding its invariants, so be careful!</p>

    <script type="text/javascript">
        window.playgroundUrl = "https://play.rust-lang.org";
    </script>
    <script src='rustbook.js'></script>
<script src='playpen.js'></script>
</div></div>


</body>
</html>